# 程序执行内存加载
当手头上有一个比较大的 c++ 工程，这个 c++ 工程是如何执行的？
## 源程序编译
首先第一个步骤是源代码的编译链接，具体流程是：源程序（.cc 文件）-> 预编译 -> 编译 -> 链接。
源程序 .cc 文件中包含数据、代码。经过编译后会生成目标文件（.o文件），目标文件中包含数据段、代码段。当所有源文件编译完成后，就会进入到链接阶段。链接阶段主要是链接一些全局变量和引用的一些函数，链接阶段会将所有的目标文件中的代码段合并、数据段合并，在进行重定位，最终生成一个目标 target。
## 程序加载
当源程序编译完成后，有可能此时编译的只是一个动态库或者静态库。如果我们此时有额外的一个 app 程序，需要调用上述的 so，就会重新编译 app 并链接已经生成的 so 文件。程序加载时，一些全局变量、静态变量（基本类型）在加载代码到内存的时候，就已经写入相应的全局变量区（静态初始化），如果是类类型，会在 main 函数之前动态初始化。 c++ 程序在执行的时候会有如下几个内存区域：代码区、常量区、静态区、堆区、栈区。
### 类内存机制
+ 虚函数指针 ----- 存储在对象中。
+ 虚函数表 ------ 属于类，存储在静态全局变量区。
+ 单继承 --- 只有一个虚函数指针。
+ 多继承 --- 每个父类的虚函数表都会生成一个虚函数指针。
+ 多态 ------ 子类对象创建内存时，内存中的虚函数指针指向的是子类的虚函数表，当基类指针指向子类对象时，指向的是子类对象的基地址，基地址一般是虚函数指针，指针内容指向子类的虚函数表，实现多态。
+ dynamic_cast  ------- 父类指针向子类指针的安全转换。只有父类函数存在虚函数时才需要使用 。dynamic_cast 首先会判断两个类之间的关系是否为继承关系，然后在进行转换，如果转换失败，就会返回 null，转换成功会返回一个子类指针。dynamic_cast运算符可以在执行期决定真正的类型。如果 downcast 是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 downcast 不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）。
+ RTTI ------ 运行时类型识别: 什么时候需要RTTI， 当一个类具有多态性质时，需要进行类型识别，换句话说，就是类中含有虚函数。
  + typeid
    + typeid 操作符会返回一个 typeInfo 结构体，通过 typeInfo.name() 可以知道表达式类型的名字。对于不含有虚函数的类类型或者基本类型，typeInfo 返回的类型在编译时就确定了，因为不需要进行运行时类型识别。当类含有虚函数的时候，每个类的虚函数表 -1 的位置记录了 typeInfo对象的指针，通过调用 typeInfo->name() 即可知道运行时类型是什么。当不含有虚函数表的时候，没有地方存放该指针，因此 typeInfo 返回的是编译时确定的类型。
  + dynamic_cast
    + (1) 计算指针或引用变量所指的对象的虚函数表的type_info信息
    + (2) 静态推导向下转型的目标类型的type_info信息，即获取类XX的type_info信息
    + 比较 (1）和 (2）中获取到的type_info信息，若2）中的类型信息与1）中的类型信息相等或是其基类类型，则返回相应的对象或子对象的地址，否则返回NULL。