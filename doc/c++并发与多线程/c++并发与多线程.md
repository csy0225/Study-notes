# C++ 并发与多线程
# 一、概念
# 1.1 并行和并发

+ 并行
    + 两个或多个独立的操作**同时进行**。
+ 并发
    + **一个时间段内**执行多个操作。
在单核时代，多个线程是并发的，在一个时间段内轮流执行；在多核时代，多个线程可以真正的实现并行。例如：4核4线程可以并行4个线程；4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。

# 1.2 并发编程类型
+ 多进程并发
    + 使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。
+ 多线程并发
    + 线程是轻量级的进程，每个线程可以执行不同的指令序列，但是线程不独立的拥有资源，依赖于创建他的线程而存在。也就是说，**同一个进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。** 这样，同一个进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。
    + 由于缺少操作系统的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁。

## 2. thread 函数
### 2.1 std::thread 的基本介绍
#### 2.1.1 构造函数
1. 构造std::thread对象时，如果不带参则会创建一个空的thread对象，但底层线程并没有真正被创建,一般可将其他std::thread对象通过move移入其中
2. 构造std::thread对象时, 如果带参则会创建新线程，而且会被立即运行。

#### 2.1.2 参数传递
+ 参数传递的次数：2 次
+ 第一次传参（std::thread 构造函数传参）: 在创建 thread 对象时，std::thread 构造函数中的所有参数均会 **按值并以副本的形式保存成一个 tuple 对象。** 该 tuple 由调用线程（一般是主线程）在堆上创建，并交由子线程管理，在子线程结束时同时被释放。注：如果要达到按引用传参的效果，可使用 std::ref 来传递。
+ 第二次传参（向线程函数传参）: 由于 std::thread 对象里面保存的是参数的副本，为了效率同时兼顾一些只移动类型的对象，所有的副本均被 std::move 到线程函数，即以右值的形式传入，所以最终传给线程函数参数的均为右值。

#### 2.1.3 线程 id
每个线程唯一对应标识，可以通过 std::this_thread::get_id() 获取。


### 2.2 join()
join 函数。调用此函数，主线程需要一直等待子线程执行完毕，才可继续往下执行。

### 2.3 detach()
将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以在后台单独运行。意味着主线程不需要等待子线程执行完毕才能往下继续运行（不阻塞主线程）。

传递临时对象作为线程参数：
+ 注意事项：
    1. 陷阱一：子线程不能使用传引用（不建议），不能传指针（不安全）
    2. 陷阱二：临时对象的转换时机：是在主线程结束之后进行转换（有问题），还是在主线程执行期间进行转换。
        + 在创建线程的同时构造临时对象是可以的，可以确保对象在主线程结束之前构造出来，从而确保调用 detach 方法是正确的，但是会多一次拷贝构造。

总结：（1）简单数据类型通过值进行传递  （2）传递类对象，避免隐士类型转换，全部都在创建线程这一行就构造出临时对象来，然后在函数参数里，用引用来接，否则会多增加构造函数的调用次数（3次） （3）建议不使用 detach(), 只使用 join(),这样就不存在局部变量相关的问题。(4) 传递智能指针参数时如果使用 std::move，同样存在内存泄露问题。（5） 成员函数作为参数，只是创建方式不同

## 3. 使用
### 3.1 创建和使用多个线程
1. 多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关。
2. 主线程等待所有子线程运行结束，最后主线程结束，推荐使用 join 写法，更容易写出稳定的程序。
3. 把 thread 对象放到容器里管理

### 3.2 数据共享问题分析
#### 3.2.1 只读数据
只读数据是安全稳定的，不需要特别处理，直接读就可以。

### 3.2.2 有读有写
例如： 2 个线程写， 8 个线程读。如果代码没有特别的处理，那程序肯定崩溃。
+ 1. 如何不崩溃？
    + 读的时候不能写， 写的时候不能读。2个线程不能同时写，8个线程不能同时读。
    + 为什么会崩溃？
        + 因为写的动作不是原子的，写的动作可以分为多步，由于多线程任务的执行顺序不一定导致各种诡异事情发生。 

## 4. 互斥量（mutex）的基本概念
是一个类对象，理解成一把锁，多个线程尝试用 lock() 成员函数来加锁，只有一个线程可以锁定成功。成功的标志是 lock() 返回值，如果没锁成功，那么流程会卡在 lock() 这里，直至返回。

### 4.1 互斥量的用法
lock() 和 unlock() 方法。
lock() 和 unlock() 要成对使用。程序的每个分支出口都需要保证和之前的 lock() 进行配对，增加 unlock()。有 lock 忘记 unlock 的情况很难排查。

为了防止忘记 unlock(),引入了一个叫 std::lock_guard 的类模板。

### 4.2 std::lock_guard 类模板
直接取代 lock() , unlock();
std::lock_guard 构造函数执行了 mutex::lock(); 析构函数里面执行了 unlock()。局部变量的原理，超出作用域后析构。

死锁： 两个以上互斥量才会出现。只要保证两个互斥量上锁的顺序一致就不会死锁。
### 4.3 std::lock() 函数模型 -- 处理多个互斥量，不会出现死锁。
一次锁住两个或者两个以上的互斥量（至少两个，多了不限）。
要么两个互斥量都锁住，要么两个互斥量都没锁住。一直在请求尝试，如果只锁了一个，另外一个没锁成功，则它立即把已经锁住的解锁。

后面要配合 mutex.unlock() 来配合。很容易产生忘记 unlock的问题。
这种情况比较少，建议一个一个互斥量锁。
### 4.4 std::lock_guard 模板 std::adopt_lock 参数
std::lock_guard<std::mutex> my_lock(my_mutex1, std::adopt_lock);
作用： std::lock_guard 配合 std::lock() 使用，std::adopt_lock 表示在构造函数中不调用 std::lock(), 他是一个结构体对象，起一个标记作用，表示 my_mutex1 已经 lock 过了，不需要在 lock 了。

### 4.5 使用 unique_lock() 取代 lock_guard
unique_lock 是个类模板，工作中一般用 lock_guard(推荐使用)。lock_guard 取代了 mutex 的 lock() 和 unlock().

#### 4.5.1 unique_lock 的其他参数
+ std::adopt_lock   
    + 表示互斥量已经被 lock 了, 如果需要使用这个参数，需要提前将互斥量进行 lock。效果是：调用方线程已经获取了互斥量的所有权。
+ std::try_to_lock
    + 尝试用 mutex 的 lock() 去锁定这个 mutex，但是如果没有锁定成功，也会立即返回，并不会阻塞在那里。 使用时互斥量切计不能先对互斥量 进行 lock().
    + 配合 owns_lock() 去使用，用来判断这个锁到底拿没拿到
    + 优点：可以在没获取到锁的情况下，做点别的事情。
+ std::defer_lock
    + 前提： 互斥量不能先被 lock 住.
    + 初始化了一个没有加锁的互斥量
    + 不用自己解锁
    + lock() 成员函数
    + unlock() 成员函数
    + trylock() 成员函数
    + release() 成员函数，返回它所管理的 mutex 指针，并放弃所有权。也就是解除绑定关系。